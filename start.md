## Start a discovery journey for Redis internals

I don't know much about `memcached`, but I used to use `Redis` and I knew it's written by ANSI C, and it should be simiar with `memcached` as Key-Value database. So I want to give it a try to add `multiply by` capability to a Redis key like `increase by`.

So I downloaded the source code of Redis from github onto my Mac, and run `make` command to build Redis. The process is quite peace and quickly.

Then I open the source code in `Visual Studio Code`, the source code structure is quite clean. All Redis implemented codes are under `src`, depedent codes are under `deps` which we can just ignore.

Under `src`, there are two folders, `commands` and `modules`, with many `*.h` and `*.c` files.

In `commands` folder, there are many JSON files whose name looks like a command in `Redis`. If you open any of them to review in detail, you'll find it defines metadata for a command, like what doesn't this command do, how's its complexity to execute, what group does it belong to, how many arguments it accepts, function name in Redis to execute real logic, etc..

It's quite easy to create a `multiplyby.json` by duplicating `incrby.json`, :). Now we have our new command metadata definition.

```json
{
    "MULTIPLYBY": {
        "summary": "Multiply the integer value of a key by args",
        "complexity": "O(1)",
        "group": "string",
        "since": "1.0.0",
        "arity": 3,
        "function": "multiplybyCommand",
        "command_flags": [
            "WRITE",
            "DENYOOM",
            "FAST"
        ],
        "acl_categories": [
            "STRING"
        ],
        "key_specs": [
            {
                "flags": [
                    "RW",
                    "ACCESS",
                    "UPDATE"
                ],
                "begin_search": {
                    "index": {
                        "pos": 1
                    }
                },
                "find_keys": {
                    "range": {
                        "lastkey": 0,
                        "step": 1,
                        "limit": 0
                    }
                }
            }
        ],
        "arguments": [
            {
                "name": "key",
                "type": "key",
                "key_spec_index": 0
            },
            {
                "name": "multiplier",
                "type": "integer"
            }
        ]
    }
}

```

I didn't know at that time (I didn't check Redis's README for any hint), but I guess we should follow everything `incrby` does. We can't do anything wrong by that.

So I run `grep -r "incrbyCommand" -n ./src` on terminal, and located it in some places, `commands.c`, `server.h` and `t_string.c`.

#### commands.c. 
I copied one line from `incrby`, and change the fields accordingly, very soon I had below record in `commands.c`

At that time, I didn't know that commands.c is not manually maintained, instead it's auto-generated by `generate-command-code.py` according to `commands` json files. Refer to [Commands.c](https://github.com/ctxdata/redis#commandsc)

And a funny thing happened that my added line below `incrby` was moved to other place where was under `msetnx`, I was surprised but I didn't want to dig into at that time. (Of course this is due to auto-generate process)

It's working fine that even if I added that code manually, because commands.c will be re-generated during `make` process. 

> [!IMPORTANT]
> It's really important to read official documentation before you kick off.

#### server.h
Next, I added multiplybyCommand function declaration in `server.h`, it's quite easy.

```C
void multiplybyCommand(client *c);
```

#### t_string.c
Then, we need to implement this command in `t_string.c`. From file name, you may guess this file implements all commands related to `String` category which represents the simple Key Value structure in `Redis`.

The command we intended to add is to multiply the value of a given key by a given number, `multiplyby [key] [multiplier]`

So we need to extract `key` and `multiplier` from context.

```C
void incrbyCommand(client *c) {
    long long incr;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
    incrDecrCommand(c,incr);
}
```

From implementation of `incrbyCommand`, we know `c->argv` holds the arguments we entered from `redis-cli`. So we can similiarly do like that to extract `multiplier`.
```C
void multiplybyCommand(client *c) {
    long long multiplier;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &multiplier, NULL) != C_OK) return;
    ...
```

After reviewing code, I think we can reuse most code for incrbyCommand, so I extract common code from incrDecrCommand to opCommand, and add additional argument to represent `incr/decr` and `multiply`.

```C
/**
 * @brief math operation
 * 
 * @param c 
 * @param operand 
 * @param op 
 *      0: incr or decr
 *      1: multiply
 *      2: divide
 */
void opCommand(client *c, long long operand, unsigned int op) {
```

I think the implementation is not difficult to any experienced developer, just one thing to be careful. `OVERFLOW`!! Actually we can refer to the overflow check for increase/decrease.

```C
        if ((operand < 0 && oldvalue < 0 && operand < (LLONG_MIN-oldvalue)) ||
            (operand > 0 && oldvalue > 0 && operand > (LLONG_MAX-oldvalue))) {
            addReplyError(c,"increment or decrement would overflow");
            return;
        }
```

So it's easy to handle in multiply like below:

```C
            if (operand < 1) {
                addReplyError(c, "multiplyby must be greater than 0");
                return;
            } else if (operand >= LLONG_MAX / oldvalue) {
                addReplyError(c,"multiplyby would overflow");
                return;
            }
            value *= operand;
```

Below is the full code snippets:
```C
/**
 * @brief math operation
 * 
 * @param c 
 * @param operand 
 * @param op 
 *      0: incr or decr
 *      1: multipy
 *      2: divide
 */
void opCommand(client *c, long long operand, unsigned int op) {
    long long value, oldvalue;
    robj *o, *new;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return;
    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;

    oldvalue = value;
    if (op > 0) {
        // multiply or divide
        if (op == 1) { 
            if (operand < 1) {
                addReplyError(c,"multiplyby must be greater than 0");
                return;
            } else if (operand >= LLONG_MAX / oldvalue) {
                addReplyError(c,"multiplyby would overflow");
                return;
            }
            value *= operand;
        } else if (op == 2) {
            if (operand < 1) {
                addReplyError(c,"multiplyby must be greater than 0");
                return;
            }
            value /= operand;
        } else {
            addReplyError(c,"invalid operator!");
            return;
        }
    } else {
        if ((operand < 0 && oldvalue < 0 && operand < (LLONG_MIN-oldvalue)) ||
            (operand > 0 && oldvalue > 0 && operand > (LLONG_MAX-oldvalue))) {
            addReplyError(c,"increment or decrement would overflow");
            return;
        }
        value += operand;
    }

    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
        value >= LONG_MIN && value <= LONG_MAX)
    {
        new = o;
        o->ptr = (void*)((long)value);
    } else {
        new = createStringObjectFromLongLongForValue(value);
        if (o) {
            dbOverwrite(c->db,c->argv[1],new);
        } else {
            dbAdd(c->db,c->argv[1],new);
        }
    }
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
    server.dirty++;
    addReplyLongLong(c, value);
}

void multiplybyCommand(client *c) {
    long long multiplier;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &multiplier, NULL) != C_OK) return;
    opCommand(c, multiplier, 1);
}
```

Once we completed code, we'd re-make the redis-server to make changes take effect. And we can use LLDB to attach the running `redis-server` and add break point to our new function, to go through line by line to make sure correctness of our code.

```bash
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x0000000102c7ee34 redis-server`opCommand(c=0x00000001286107d0, operand=10, op=1) at t_string.c:606:27
    frame #1: 0x0000000102c7f0ac redis-server`multiplybyCommand(c=0x00000001286107d0) at t_string.c:684:5
    frame #2: 0x0000000102c45960 redis-server`call(c=0x00000001286107d0, flags=15) at server.c:3265:5
    frame #3: 0x0000000102c46cb0 redis-server`processCommand(c=0x00000001286107d0) at server.c:3906:9
    frame #4: 0x0000000102c5eee4 redis-server`processInputBuffer [inlined] processCommandAndResetClient(c=0x00000001286107d0) at networking.c:2438:9
    frame #5: 0x0000000102c5eed4 redis-server`processInputBuffer(c=0x00000001286107d0) at networking.c:2542:17
    frame #6: 0x0000000102c5735c redis-server`readQueryFromClient(conn=<unavailable>) at networking.c:2673:9
    frame #7: 0x0000000102d08414 redis-server`connSocketEventHandler [inlined] callHandler(conn=0x0000600001bf4000, handler=<unavailable>) at connhelpers.h:79:18
    frame #8: 0x0000000102d08400 redis-server`connSocketEventHandler(el=<unavailable>, fd=<unavailable>, clientData=0x0000600001bf4000, mask=<unavailable>) at connection.c:310:14
    frame #9: 0x0000000102c3be08 redis-server`aeProcessEvents(eventLoop=0x0000600002dfcf00, flags=27) at ae.c:436:17
    frame #10: 0x0000000102c3c078 redis-server`aeMain(eventLoop=0x0000600002dfcf00) at ae.c:496:9
    frame #11: 0x0000000102c4cea8 redis-server`main(argc=2, argv=<unavailable>) at server.c:7085:5
    frame #12: 0x0000000102ef5088 dyld`start + 516
```

Next time, I'd like to add a module to Redis. [Module in Redis](https://redis.io/docs/reference/modules/)

I believe it will help us under deeper if we can add some features into a program.
